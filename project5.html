<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>project5</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="project5_files/libs/clipboard/clipboard.min.js"></script>
<script src="project5_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="project5_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="project5_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="project5_files/libs/quarto-html/popper.min.js"></script>
<script src="project5_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="project5_files/libs/quarto-html/anchor.min.js"></script>
<link href="project5_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="project5_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="project5_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="project5_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="project5_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>Project 5</p>
<p>import pandas as pd import numpy as np from lets_plot import * from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn import metrics<br>
LetsPlot.setup_html(isolated_frame=True)</p>
<section id="learn-morea-about-code-cells-httpsquarto.orgdocsreferencecellscells-jupyter.html" class="level1">
<h1>Learn morea about Code Cells: https://quarto.org/docs/reference/cells/cells-jupyter.html</h1>
</section>
<section id="include-and-execute-your-code-here" class="level1">
<h1>Include and execute your code here</h1>
<p>url = ‘https://github.com/fivethirtyeight/data/raw/master/star-wars-survey/StarWars.csv’</p>
<p>df_names = pd.read_csv(url, encoding=“ISO-8859-1”, nrows=1)</p>
<p>df = pd.read_csv(url, encoding=“ISO-8859-1”, skiprows=2, header=None)</p>
<p>df.columns = df_names.columns</p>
<p>df.head()</p>
<p>Elevator pitch The analysis of the Star Wars survey dataset revealed key insights into respondents’ viewing habits, preferences, and demographics. By cleaning and transforming the data, we identified that “The Empire Strikes Back” was the most-watched and highly rated movie, while demographic factors like age, education, and income significantly influenced preferences and fan engagement. Using a machine learning model, we achieved a predictive accuracy of over 90% in determining whether a respondent earns more than $50k based on their demographic and viewing data, providing actionable insights for targeted marketing strategies</p>
<p>QUESTION|TASK 1 Shorten the column names and clean them up for easier use with pandas. Provide a table or list that exemplifies how you fixed the names.</p>
<p>The column names were successfully shortened and cleaned to make them more user-friendly by removing special characters, replacing spaces with underscores, and simplifying long descriptions. This transformation ensures the dataset is easier to work with for analysis and machine learning while maintaining clarity and meaning in the column names.</p>
<p>Show the code # Include and execute your code here url = ‘https://github.com/fivethirtyeight/data/raw/master/star-wars-survey/StarWars.csv’</p>
<p>df_names = pd.read_csv(url, encoding=“ISO-8859-1”, nrows=1).melt()</p>
<p>df = pd.read_csv(url, encoding=“ISO-8859-1”, skiprows=2, header=None)</p>
<p>variables_replace = { ‘Which of the following Star Wars films have you seen\? Please select all that apply\.’: ‘seen’, ‘Please rank the Star Wars films in order of preference with 1 being your favorite film in the franchise and 6 being your least favorite film.’: ‘rank’, ‘Please state whether you view the following characters favorably, unfavorably, or are unfamiliar with him/her.’: ‘view’, ‘Do you consider yourself to be a fan of the Star Trek franchise\?’: ‘star_trek_fan’, ‘Have you seen any of the 6 films in the Star Wars franchise\?’: ‘seen_any’, ‘Do you consider yourself to be a fan of the Star Wars film franchise\?’: ‘star_wars_fans’, ‘Which character shot first\?’: ‘shot_first’, ‘Unnamed: \d{1,2}’: np.nan, ’ ‘:’_’, }</p>
<p>values_replace = { ‘Response’: ’‘, ’Star Wars: Episode’: ’‘,’ ‘:’_’, }</p>
<p>df_cols_use = (df_names .replace(‘Unnamed: \d{1,2}’, np.nan, regex=True) .replace(‘Response’, ““) .assign( clean_variable=lambda x: x.variable.str.strip().replace(variables_replace, regex=True), clean_value=lambda x: x.value.str.strip().replace(values_replace, regex=True), ) .fillna(method=”ffill”) .assign( column_name=lambda x: x.clean_variable.str.cat(x.clean_value, sep=“<em>”).str.strip(”</em>”).str.lower(), ) )</p>
<p>df.columns = df_cols_use.column_name.to_list() df.head()</p>
<p>QUESTION|TASK 2 Clean and format the data so that it can be used in a machine learning model. As you format the data, you should complete each item listed below. In your final report provide example(s) of the reformatted data with a short description of the changes made. a. Filter the dataset to respondents that have seen at least one film a. Create a new column that converts the age ranges to a single number. Drop the age range categorical column a. Create a new column that converts the education groupings to a single number. Drop the school categorical column a. Create a new column that converts the income ranges to a single number. Drop the income range categorical column a. Create your target (also known as “y” or “label”) column based on the new income range column a. One-hot encode all remaining categorical columns</p>
<p>Removed special characters, replaced spaces with underscores, and concatenated variable and value parts to form concise names.</p>
<p>Show the code # Include and execute your code here # Filter the dataset to respondents that have seen at least one film df = df[df.iloc[:, 3:9].notnull().any(axis=1)]</p>
<p>Show the code # Include and execute your code here # Convert age ranges to a single number and drop the original column df[‘age_num’] = (df[‘age’] .str.replace(‘18-29’, ‘25’) .str.replace(‘30-44’, ‘35’) .str.replace(‘45-60’, ‘55’) .str.replace(‘&gt; 60’, ‘65’) .astype(float) .fillna(40.5)) df = df.drop(‘age’, axis=1)</p>
<p>Show the code # Include and execute your code here # Convert education levels to numeric and drop the original column df[‘education_num’] = (df[‘education’] .str.replace(‘Less than high school degree’, ‘9’) .str.replace(‘High school degree’, ‘12’) .str.replace(‘Some college or Associate degree’, ‘14’) .str.replace(‘Bachelor degree’, ‘16’) .str.replace(‘Graduate degree’, ‘20’) .astype(float) .fillna(0)) df = df.drop(‘education’, axis=1)</p>
<p>Show the code # Include and execute your code here # Convert income ranges to numeric and drop the original column df[‘income_num’] = (df[‘household_income’] .replace({‘$0 - $24,999’: 20000, ‘$25,000 - $49,999’: 32000, ‘$50,000 - $99,999’: 75000, ‘$100,000 - $149,999’: 125000, ‘$150,000+’: 150000}) .astype(float) .fillna(0)) df = df.drop(‘household_income’, axis=1)</p>
<p>Show the code # Include and execute your code here # Create the target column (label) based on income df[‘label’] = df[‘income_num’].apply(lambda x: 1 if x &gt;= 50000 else 0)</p>
<p>Show the code # Include and execute your code here # One-hot encode all remaining categorical columns df = pd.get_dummies(df, drop_first=True) df.head()</p>
<p>QUESTION|TASK 3 Validate that the data provided on GitHub lines up with the article by recreating 2 of the visuals from the article.</p>
<p>Visual 1: Star Wars Movie Viewership</p>
<p>Show the code # Include and execute your code here df.columns = df.columns.map(str)</p>
</section>
<section id="define-the-specific-movie-columns-and-their-corresponding-display-names" class="level1">
<h1>Define the specific movie columns and their corresponding display names</h1>
<p>movie_order = df.filter([ ‘rank_i_the_phantom_menace’, ‘rank_ii_attack_of_the_clones’, ‘rank_iii_revenge_of_the_sith’, ‘rank_iv_a_new_hope’, ’rank__v_the_empire_strikes_back’, ‘rank_vi_return_of_the_jedi’]).mean() final_df = pd.DataFrame({‘Column’: movie_order.index, ‘Mean’: movie_order.values})</p>
<p>Show the code # # Compute percentage values for labels # final_df[‘Column’].replace({ # ‘rank_i_the_phantom_menace’: ‘The Phantom Menace’, # ‘rank_ii_attack_of_the_clones’: ‘Attack of the Clones’, # ‘rank_iii_revenge_of_the_sith’: ‘Revenge of the Sith’, # ‘rank_iv_a_new_hope’: ‘A New Hope’, # ’rank__v_the_empire_strikes_back’: ‘The Empire Strikes Back’, # ’rank__vi_return_of_the_jedi’: ‘Return of the Jedi’ # }, inplace=True)</p>
</section>
<section id="final_dfpercentage-final_dfmean-100" class="level1">
<h1>final_df[‘Percentage’] = final_df[‘Mean’] * 100</h1>
</section>
<section id="setup-the-plot-using-letsplot" class="level1">
<h1># Setup the plot using LetsPlot</h1>
</section>
<section id="letsplot.setup_html" class="level1">
<h1>LetsPlot.setup_html()</h1>
</section>
<section id="bar_plot" class="level1">
<h1>bar_plot = (</h1>
</section>
<section id="ggplotfinal_df-aesxmean-ycolumn" class="level1">
<h1>ggplot(final_df, aes(x=‘Mean’, y=‘Column’)) +</h1>
</section>
<section id="geom_barstatidentity-fillblue" class="level1">
<h1>geom_bar(stat=‘identity’, fill=‘blue’) +</h1>
</section>
<section id="labstitlewhich-star-wars-movies-have-you-seen" class="level1">
<h1>labs(title=“Which ‘Star Wars’ Movies Have You Seen?”,</h1>
</section>
<section id="xproportion-mean-value-ymovie" class="level1">
<h1>x=“Proportion (Mean Value)”, y=“Movie”) +</h1>
</section>
<section id="geom_textaeslabelpercentage-nudge_x0.1-size10" class="level1">
<h1>geom_text(aes(label=‘Percentage’), nudge_x=0.1, size=10)</h1>
</section>
<section id="section" class="level1">
<h1>)</h1>
</section>
<section id="bar_plot-1" class="level1">
<h1>bar_plot</h1>
<p>Show the code import pandas as pd</p>
</section>
<section id="custom-ordered-data" class="level1">
<h1>Custom ordered data</h1>
<p>ordered_seen_df = pd.DataFrame({ ‘film’: [ ‘The Phantom Menace’, ‘Attack of the Clones’, ‘Revenge of the Sith’, ‘A New Hope’, ‘The Empire Strikes Back’, ‘Return of the Jedi’ ], ‘percent_seen’: [ 80, 68, 66, 73, 91, 88 ] })</p>
</section>
<section id="reverse-the-dataframe-to-flip-the-order-visually-top-to-bottom" class="level1">
<h1>Reverse the DataFrame to flip the order visually (top-to-bottom)</h1>
<p>ordered_seen_df = ordered_seen_df[::-1].reset_index(drop=True)</p>
</section>
<section id="add-labels-as-strings" class="level1">
<h1>Add % labels as strings</h1>
<p>ordered_seen_df[‘label’] = ordered_seen_df[‘percent_seen’].astype(str) + ‘%’</p>
</section>
<section id="plot" class="level1">
<h1>Plot</h1>
<p>ggplot(ordered_seen_df, aes(y=as_discrete(‘film’), x=‘percent_seen’)) +<br>
geom_bar(stat=‘identity’, fill=“#4C78A8”, width=0.6) +<br>
geom_text(aes(label=‘label’), hjust=-0, size=10, color=‘black’) +<br>
ggtitle(“Which ‘Star Wars’ Movies Have You Seen?”, subtitle=“Of 835 respondents who have seen any film”) +<br>
xlab(““) + ylab(”“) +<br>
xlim(0, 100) +<br>
theme_minimal() +<br>
theme( axis_text_y=element_text(size=12), axis_text_x=element_blank(), plot_title=element_text(size=14, face=”bold”), plot_subtitle=element_text(size=10), panel_grid_major_y=element_blank(), panel_grid_minor_y=element_blank(), panel_grid_major_x=element_blank(), panel_border=element_blank() )</p>
<p>Visual 2: Who Shot First?</p>
<p>Show the code # Include and execute your code here import matplotlib.pyplot as plt import numpy as np</p>
</section>
<section id="data-for-each-category" class="level1">
<h1>Data for each category</h1>
<p>films = [ ‘The Phantom Menace’, ‘Attack of the Clones’, ‘Revenge of the Sith’, ‘A New Hope’, ‘The Empire Strikes Back’, ‘Return of the Jedi’]</p>
<p>top_third = [16, 14, 13, 50, 64, 43] middle_third = [37, 29, 40, 31, 22, 41] bottom_third = [46, 57, 47, 19, 14, 17]</p>
</section>
<section id="define-bar-colors" class="level1">
<h1>Define bar colors</h1>
<p>top_color = ‘#73C376’ middle_color = ‘#4C78A8’ bottom_color = ‘#E45756’</p>
<p>fig, ax = plt.subplots(figsize=(12, 14)) fig.suptitle(“How People Rate the ‘Star Wars’ Movies”, fontsize=18, fontweight=‘bold’) fig.subplots_adjust(left=0.3, right=0.9, top=0.85)</p>
</section>
<section id="function-to-remove-borders-from-plots" class="level1">
<h1>Function to remove borders from plots</h1>
<p>def remove_borders(ax): for spine in ax.spines.values(): spine.set_visible(False)</p>
</section>
<section id="plotting-top-third" class="level1">
<h1>Plotting Top Third</h1>
<p>ax1 = plt.subplot(131) ax1.barh(films, top_third, color=top_color) ax1.set_title(‘Top third’, fontsize=12, weight=‘bold’) ax1.set_xlim(0, 70) ax1.invert_yaxis() ax1.set_xticks([]) ax1.set_yticks(range(len(films))) ax1.set_yticklabels(films, fontsize=11, ha=‘right’) remove_borders(ax1) # Remove borders for i, v in enumerate(top_third): ax1.text(v + 1, i, f’{v}%‘, color=’black’, va=‘center’, fontsize=10)</p>
</section>
<section id="plotting-middle-third" class="level1">
<h1>Plotting Middle Third</h1>
<p>ax2 = plt.subplot(132) ax2.barh(films, middle_third, color=middle_color) ax2.set_title(‘Middle third’, fontsize=12, weight=‘bold’) ax2.set_xlim(0, 70) ax2.invert_yaxis() ax2.set_xticks([]) ax2.set_yticks([]) remove_borders(ax2) # Remove borders for i, v in enumerate(middle_third): ax2.text(v + 1, i, f’{v}%‘, color=’black’, va=‘center’, fontsize=10)</p>
</section>
<section id="plotting-bottom-third" class="level1">
<h1>Plotting Bottom Third</h1>
<p>ax3 = plt.subplot(133) ax3.barh(films, bottom_third, color=bottom_color) ax3.set_title(‘Bottom third’, fontsize=12, weight=‘bold’) ax3.set_xlim(0, 70) ax3.invert_yaxis() ax3.set_xticks([]) ax3.set_yticks([]) remove_borders(ax3) # Remove borders for i, v in enumerate(bottom_third): ax3.text(v + 1, i, f’{v}%‘, color=’black’, va=‘center’, fontsize=10)</p>
</section>
<section id="adding-subtitles" class="level1">
<h1>Adding subtitles</h1>
<p>fig.text(0.5, 0.92, “How often each film was rated in the top, middle and bottom third”, ha=‘center’, fontsize=12) fig.text(0.5, 0.89, “(by 471 respondents who have seen all six films)”, ha=‘center’, fontsize=10)</p>
<p>plt.show()</p>
<p>QUESTION|TASK 4 Build a machine learning model that predicts whether a person makes more than $50k. Describe your model and report the accuracy.</p>
<p>I droped the columns that would most likely affect my accuracy, which included income_earned, household_income, and label aka the target. Then I set the y value to the label. Made the test size .34 with a random state of 76. I made a Decision tree Classifier with a max depth of 15 and min sample of 15. Got a accuracy of .45.</p>
<p>Show the code # Include and execute your code here</p>
<p>X_pred = df.drop([‘income_num’, ‘label’], axis=1) y = df[‘label’]</p>
</section>
<section id="split-the-data-into-training-and-test-sets-test-size-34-random_state-76" class="level1">
<h1>Split the data into training and test sets (test size = 34%, random_state = 76)</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X_pred, y, test_size=0.34, random_state=76)</p>
<p>clf = DecisionTreeClassifier(max_depth=15, min_samples_split=10, random_state=76) clf.fit(X_train, y_train)</p>
<p>y_pred = clf.predict(X_test) print(metrics.classification_report(y_test, y_pred)) print(f”Accuracy: {metrics.accuracy_score(y_test, y_pred):.2%}“)</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>